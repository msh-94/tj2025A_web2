[ 데이터베이스 ] : SQL(MYSQL/ORACLE) , NOSQL(REDIS)
[ JDBC ] : 자바 와 DB 연동 인터페이스
    DAO( JDBC ) , MYBATIS , JPA

[ ORM ] O : object , R : Relational , M : Mapping : 객체관계매핑 *기술*
    1. 정의 : 객체지향 프로그래밍에서 사용되는 객체 와 DB(관계형데이터베이스) 매핑
    2. 목적 : 편리성 제공
    3. 사용처 : MYBATIS , JPA 등등

[ Hibernate ] :
    1. 정의 : 자바에서 ORM 구현한 라이브러리
    2. 목적 : SQL 없이 순수 자바만으로 데이터베이스 처리한다
    3. 기능 : 1.CRUD 2.타입변환 3.부가기능(검색/정렬/페이징처리) 등등

[ JPA ] J : java , P : persistence(영속성) , A : api
    자바 영속성/지속성/고집 API
    1. 정의 : 자바에서 ORM 사용할때 표준 API, 자바에서 다양한 라이브러리 제공
    2. 설치 : implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    3. 기능 : 영속된 관계에서 자바객체가 변화되면 데이터베이스도 같이 변경
[ Entity ]
    1. 정의 : 데이터베이스 테이블과 매핑된 클래스
    Entity클래스 = DB테이블(표) , Entity객체 = 레코드(행)
        - 클래스 = 객체의 설계도
        class Memeber{
            int id;
            String name;
        }
        - 객체 = 클래스의 인스턴스
        new Member( 1 , "유재석" )
    2. 사용법
        1) 선언 : 클래스 위에 @Entity 주입한다
        + 엔티티 1개당 @Id 1개는 필수다 , ( primary key )
        2) Entity 매핑 설정 , application.properties
            2-1) spring.jpa.hibernate.ddl-auto =
                create : Entity 테이블 (삭제후)생성
                update : Entity 테이블 (존재하면)수정 (존재하지않으면)생성
                none : 아무런기능 없음(기본값)
            2-2)
                # JPA 가 처리한 SQL 콘솔에 표시한다
                spring.jpa.show-sql=true
                # 콘솔에 출력된 sql 형식(줄바꿈) 표시한다
                spring.jpa.properties.hibernate.format_sql=true
                # JPA 가 처리한 SQL 매개변수(?) 콘솔 표시한다
                logging.level.org.hibernate.sql=debug
                logging.level.org.hibernate.orm.jdbc.bind=trace
    3. 주요 어노테이션
        - @Entity                    : 해당 클래스를 데이터베이스 테이블과 매핑
        - @Id                        : 해당 클래스/테이블의 PRIMARY KEY 주입
        - @Table(name="테이블명")     : 해당 테이블 명 정의
        - @GeneratedValue( strategy = GenerationType.IDENTITY ) : auto_increment 정의
        - @Column( 옵션명 = 값 , 옵션명 = 값 )                     : 테이블 속성(열/컬럼) 정의
            -> nullable = true/false    : not null 제약조건
            -> unique = false/true      : unique 제약조건
            -> name = "필드명"           : 필드명 정의 , 생략시 자바 변수명 자동
            -> length = 길이             : 길이가 존재하는 필드의 길이 정의
            -> insertable = true/false  : insert 할때 적용할 필드 설정
            -> updatable = true/false   : update 할때 적용할 필드 설정
            * columnDefinition = "로컬 DB 구문 직접 작성"

[ 리포지토리 ] JPA Repository
    1. 정의 : 기본적인 CRUD 작업을 제공하는 인터페이스, +동적쿼리 , +JPQL
    2. 사용법
        1) 인터페이스 생성
        2) extends JpaRepository< T , ID > 상속 받는다
            T : 조작할 엔티티클래스명
            ID : 조작할 엔티티클래스의 PK필드(@ID)의 자료형 * 단 기본자료형 불가능 *
        3) 인터페이스 위에 @Repository 주입한다

[ JPA 기본함수 ] * 영속화 : 영속된 결과를 반환한다
    1. .save( 저장할엔티티 )      : 저장할엔티티가 존재하지않으면 INSERT, 존재하면 UPDATE
    2. .findAll( )              : 모든 엔티티 조회 , List 타입 반환
    3. .deleteById( pk값 )       : 특정한 pk값의 엔티티 삭제 * Optional 타입 반환
    4. .findById( pk값 )         : 특정한 pk값의 엔티티 1개 조회
    5. .existsById( pk값 )       : 특정한 pk값이 존재하면 true 없으면 false
    * 수정함수는 존재하지 않는다<영속성 특징>
        - 영속성을 갖는 시점 : save,findAll,findById 등등 반환 된 엔티티가 영속된 엔티티
        - @Transactional 갖는 클래스 또는 메소드내 .setter 함수 이용하여 수정처리한다
        - 관례적으로 엔티티는 MVC 패턴내 서비스에서만 사용한다 < 엔티티 노출 하지 않는다 > DTO/VO 활용

[ Optional ] : Null 관련된 메소드 기능 제공하는 클래스
    1. .isPresent() : null 이면 false, 아니면 true
    2. .get() : 객체 반환
    3. .orElse( null 일때 값 )
    4. .orElseThrow( 예외객체 )

[ JPA Auditing ]
    1. 정의 : 엔티티의 생성/수정 변화를 기록하는걸 자동으로 감시하는 기능
    2. 목적 : SQL INSERT/UPDATE 감시하여 기록한다
    3. 사용처 : BaseTime 상속 클래스
    4. 사용법 :
        1) AppStart 클래스 위에 @EnableJpaAuditing 활성화 한다
        2) BaseTime 클래스 생성
            @Getter // 롬복 getter
            @MappedSuperclass // 엔티티 상속용도
            @EntityListeners( AuditingEntityListener.class ) // 해당 엔티티를 자동 감시 적용
            public class BaseTime {
                @CreatedDate // 현재 날짜/시간을 자동으로 주입
                private LocalDateTime createDate; // 생성날짜/시간
                // LocalDateTime --> datetime(6)

                @LastModifiedDate // 엔티티 변화 시점의 날짜/시간을 자동으로 주입
                private LocalDateTime updateDate; // 수정날짜/시간
            }// class end
        3) BaseTime 적용할 엔티티클래스에 'extends BaseTime' 상속 받는다

[ JPA entity 와 MVC DTO/VO 관계/변환 ]
    - spring web 은 MVC2 3tire 패턴 사용한다
    - Entity 클래스는 toDto 메소드 정의하여 변환 메소드 정의한다
    - Dto 클래스는 toEntity 메소드 정의하여 변환 메소드 정의한다

    ( view )    <--JSON/DTO-->  (controller)    <-- DTO -->    (service)  <-- Entity -->  Repository/DAO/Mapper
    HTML/JS                     @RestController                @Service
    JSP/JS                      --> DTO/MAP 권장              --> 비즈니스로직
    REACT(+JS)                                               --> DTO --> Entity
    Flutter                                                 <-- DTO <-- Entity

[ JPA 연관관계 ]
    1. 정의 : 여러 앤티티들 간의 참조 관계
    2. 참조 방향
        - 단방향 : 한 엔티티가 다른 엔티티만 참조
        - 양방향 : 서로가 서로 엔티티를 참조
    3. 사용법
        1) 단방향 : @ManyToOne( cascade = CascadeType.ALL , fetch = FetchType.LAZY )
            -> @JoinColumn( name = "FK 필드명 정의" )
        2) 양방향 : @OneToMany( mappedBy = "참조할 단방향의 멤버변수명" )
            -> @ToString.Exclude : 순환참조 방지
            -> @Builder.Default : @Builder 패턴 사용시 현재 초기값 사용
    4. 영속성 제약조건 옵션
        1) cascade
            cascade = CascadeType.ALL : 부모가 삭제/수정/저장 되면 자식도 같이 삭제/수정/저장 된다
            cascade = CascadeType.PERSIST : 부모가 *저장* 되면 자식도 같이 *저장* 된다
            cascade = CascadeType.MERGE : 부모가 *수정* 되면 자식도 같이 *수정* 된다
            cascade = CascadeType.REMOVE : 부모가 *삭제* 되면 자식도 같이 *삭제* 된다
            cascade = CascadeType.REFRESH : 부모 재호출(갱신) 되면 자식도 같이 재호출(갱신) 된다
            cascade = CascadeType.DETACH : 부모가 영속 해제 되면 자식도 같이 영속 해제 된다
        2) fetch
            fetch = FetchType.EAGER : 해당 엔티티를 조회하면 참조 엔티티도 즉시 조회한다
                - 특징 : 기본값 , 초기 로딩 느리다 , *불필요한 엔티티 정보*가 있을경우 기능 저하
            fetch = FetchType.LAZY : 해당 엔티티를 조회하면 참조 엔티티를 조회 하지 않는다
                - 특징 : 초기 로딩 빠르다 , 사용할 엔티티 정보를 적절하게 사용하면 성능 최적화
                - 해당엔티티.getXXX() 하는 순간 그때 참조 엔티티 조회